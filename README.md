# VOOGASalad
For this project, I worked on a team with ten other students to design a game-authoring environment in Java to allow users to build arcade-style 2D video games of the scrolling-platformer genre.

## My Module's Design
I worked on pretty much all parts of our project's game engine with the exception of all of the collision logic and systems. The engine is comprised of a few main abstractions: entities, components, systems, and events (which have conditions and actions).

`Component` objects specify attributes. One example of a `Component` is a `VisibilityComponent`, which is an attribute that specifies whether or not an `Entity` should be visualized on screen or not. Another example of a `Component` is the `HealthComponent`, which specifies how much health an entity has remaining in the level. `Component` is a generic interface that exposes two methods that get and set that given component's internal value, whatever type it may be.

`Entity` objects aggregate `Component` objects in a way that gives `Entity` objects a kind of character or personality, if you will. For example, an `Entity` that a user may want to use as a block might have components that specify its position, visuals, and ability to collide with other things. Adding the right components to that entity allows it to have block-like characteristics.

`Systems` are what actually operate on the `Entity` objects' components. `Systems` are basically behaviors for entities that don't belong specifically to individual entities; they are shared amongst _all entities with specific components_. For example, we had a `HorizontalPositionSystem` that acted on all entities containing an `XPosComponent` and an `XVelComponent`. The assumption is that if an entity contains both of those components, it has the ability to move in the horizontal dimension. If an `Entity` didn't contain both of those components, it wouldn't be acted on because its attributes didn't suggest that that behavior was allowable. `Systems` implement the `GameSystem` interface, which specifies a single method `void act(double elapsedTime, Level level)`. This allows for them to be called very polymorphically in a loop within `Engine.java`. The access to the current `Level` object allows the `Systems` to query for entities containing the `Components` that that `System` needs to execute. Systems provide the "activity" in ECS. ECS breaks from traditional OOD in a handful of ways, with potentially the biggest departure coming in how inactive `Components` are. `Components` are extremely open classes; they do nothing besides allow you to get and set their data at will. I recognize that fact, and I know it's not ideal. But it's also really important to think about the tradeoffs and what that allowed us to do: specify a _single_ `System` that could act on _any_ entity with given components. Those `Systems` became the "activity" that is so often talked about in the OOD world, it just exists in a different place. Whereas traditional OOD models would suggest having that activity on the entities themselves, that activity now lives within the `Systems`. We gave up having closed and active objects in favor of extreme flexibility with really flat hierarchies. That was our tradeoff and we took it.

Lastly, `Event` objects are built using some combination of `Condition` objects and `Action` objects. Think of it as `if (all Condition objects evaluate to true), execute all of the Actions`. The `Event` class implements two interfaces that separate the functionality used by the authoring environment and the game player. The `AuthorableEvent` interface contains methods for adding `Conditions` and `Actions` to an `Event` as well as methods to retrieve those `Conditions` and `Actions` for display. The only method in the `PlayableEvent` class is the `void occur()` method which evaluates each of its conditions and acts accordingly. Events are each evaluated once per game loop.

I tried to come up with the most generalized conditions that I could: if two entities collide (`EntityCollisionCondition`), if any one of an `Entity`'s `Component` attributes is less than, less than or equal to, equal to, greater than, greater than or equal to, or not equal to some value (`DataCondition`), if a certain key has been pressed (`KeyboardInputCondition`), if the mouse has been clicked (`MouseInputCondition`), or if one entity collides with another entity with a specific `Component` (`ComponentCollisionCondition`). These conditions are really powerful and represent nearly everything that can happen in a game. The `Condition` interface specifies one method that must be implemented: `boolean evaluate()`.

`DataCondition` is a particularly powerful `Condition` that uses the [EvalEx library](https://github.com/uklimaschewski/EvalEx) to compute. It allows you to perform any kind of comparison between any components' value, using any comparator and any expected value. You can check to see if an `Entity`'s y-velocity exceeds some threshold or if its x-position is lower than some value. `CollisionCondition` is also extremely useful because many actions in a game occur as a result of two things coming into contact with each other.

We viewed `Action` objects as essentially glorified lambdas. They take some arguments and perform some operation on those arguments. We separated our `Action` objects into two separate packages, `micro` and `macro`. `Actions` in the `micro` package operate on entities whereas `Actions` in the `macro` package operate on the `Level` or `Engine`. It was a separation that served no functional purpose other than to indicate to a user of those classes what level of abstraction the `Action` they were using would be working. The `Action` interface specifies one method, `void execute()`, which gets called if all of the `Conditions` contained within that `Event` evaluate to true.

`Events`, `Conditions`, and `Actions` are all very polymorphic due to the interfaces they implement. Looping over each of them, storing them in a collection, and calling each of their primary methods is really straightforward and requires no understanding of the underlying implementation or the exact kind of subclass they each represent. The use of interfaces for `Conditions` and `Actions` means that they satisfy the Open-Closed Principle. If you want to extend the `Condition` abstraction, for example, you simply add a new class that implements the `Condition` interface and then provide the implementation. There's no need to modify any of the existing code at all. The same goes for `Actions`. `Events` hold references to different combinations of `Conditions` and `Actions` instead of implementing that behavior by inheriting from some superclass. Composition allows us to not have to find some kind of commonality between different kinds of conditions or actions. There isn't really much that `KeyboardInputConditions` have in common with `EntityCollisionConditions`, so having to cram those into an inheritance hierarchy would be painful. Using interfaces and composition is much more flexible and extensible.

`Entity` objects also favor composition over inheritance: an entity is composed by its attributes rather than having to inherit those attributes. In the context of this project, it meant that we could define a stationary, impassable block just as easily as we could define a  moving, coin-collecting player. They use the exact same abstractions, just in different combinations. It was a really powerful engine design that, again, very much satisfied the open-closed principle. Whenever we wanted to add a new feature, we would add new classes that implemented the `Component` interface and perhaps also add a `System` that could act on it. We never had to go back and modify existing classes to extend their functionality, we simply added new subclasses.

`Engine` and `Level` exist above all of the abstractions I just mentioned. `Engine` provides a lot of utility in managing the `Level` objects and is also the place where input was received. `Levels` primarily provide the logic for filtering `Entity` objects by `Component` type and also expose methods to add and remove `Entity` and `Event` objects.

The last point I'd like to make in talking about the high level design of my code is the balance I struck between composition and inheritance. Even though I did favor composition for this project, I didn't ignore inheritance either. Particularly within our `Systems`, I found it useful to have really shallow inheritance hierarchies to avoid code duplication for similar `Systems`. One example of that is with the abstract superclass `PositionSystem`, which `HorizontalPositionSystem` and `VerticalPositionSystem` both extend. The differences between the two implementations were in the `Components` they wanted to act on, not in the actual mechanics of the implementation itself. I think it's a good example of how composition and inheritance can work together; it's not a matter of using one or the other but rather using each where appropriate.
